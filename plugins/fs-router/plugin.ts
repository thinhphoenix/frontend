import { type RsbuildPlugin, rspack } from "@rsbuild/core";
import fs from "node:fs";
import path from "node:path";

export type FsRouterOptions = {
  /** Directory containing route files (default: "src/routes") */
  appDir?: string;
};

/**
 * Scan a directory recursively and return relative paths of all files.
 */
function walk(dir: string, base = ""): string[] {
  const entries: string[] = [];
  for (const d of fs.readdirSync(dir, { withFileTypes: true })) {
    const rel = base ? `${base}/${d.name}` : d.name;
    if (d.isDirectory()) {
      entries.push(...walk(path.join(dir, d.name), rel));
    } else {
      entries.push(rel);
    }
  }
  return entries;
}

/**
 * Generate the virtual module source code that exports all discovered
 * pages, layouts, not-found pages, loading UIs, and error boundaries
 * as lazy import functions.
 */
function generateRoutesModule(appDir: string, appDirAbs: string): string {
  const files = walk(appDirAbs);
  const pages = files.filter((f) => /\/page\.tsx$|^page\.tsx$/.test(f));
  const layouts = files.filter((f) => /\/layout\.tsx$|^layout\.tsx$/.test(f));
  const notFounds = files.filter((f) => /\/not-found\.tsx$|^not-found\.tsx$/.test(f));
  const loadings = files.filter((f) => /\/loading\.tsx$|^loading\.tsx$/.test(f));
  const errors = files.filter((f) => /\/error\.tsx$|^error\.tsx$/.test(f));

  // Use the last segment of appDir as the prefix in keys (e.g. "src/routes" -> "routes")
  const prefix = path.basename(appDir);

  function buildEntries(list: string[]): string {
    return list
      .map((f) => {
        const key = `/${prefix}/${f}`;
        const importPath = path.resolve(appDirAbs, f).replace(/\\/g, "/");
        return `  ${JSON.stringify(key)}: () => import(${JSON.stringify(importPath)})`;
      })
      .join(",\n");
  }

  return `// Auto-generated by fs-router plugin â€” do not edit
export const routePrefix = ${JSON.stringify(prefix)};

export const pages = {
${buildEntries(pages)}
};

export const layouts = {
${buildEntries(layouts)}
};

export const notFounds = {
${buildEntries(notFounds)}
};

export const loadings = {
${buildEntries(loadings)}
};

export const errors = {
${buildEntries(errors)}
};
`;
}

export const pluginFsRouter = (
  options: FsRouterOptions = {}
): RsbuildPlugin => ({
  name: "plugin-fs-router",
  setup(api) {
    const appDir = options.appDir ?? "src/routes";

    api.modifyRspackConfig((config, { isDev }) => {
      const rootDir = api.context.rootPath;
      const appDirAbs = path.resolve(rootDir, appDir);
      const runtimePath = path.resolve(rootDir, "plugins/fs-router/runtime");

      if (!fs.existsSync(appDirAbs)) {
        throw new Error(
          `[plugin-fs-router] App directory "${appDirAbs}" does not exist.`
        );
      }

      // Generate virtual routes module
      const routesSource = generateRoutesModule(appDir, appDirAbs);

      // Register VirtualModulesPlugin
      // Use a plain path (not a URI scheme like "virtual:") so Rspack can resolve it
      const virtualModuleName = path.resolve(rootDir, "node_modules/.virtual/fs-routes.js");
      const virtualPlugin = new rspack.experiments.VirtualModulesPlugin({
        [virtualModuleName]: routesSource,
      });

      // Alias so runtime can `import { pages, layouts } from "virtual-fs-routes"`
      (config.resolve.alias as Record<string, string>)["virtual-fs-routes"] =
        virtualModuleName;
      config.plugins ??= [];
      config.plugins.push(virtualPlugin);

      // Alias so app code can `import { Link } from "fs-router/runtime"`
      config.resolve ??= {};
      config.resolve.alias ??= {};
      (config.resolve.alias as Record<string, string>)["fs-router/runtime"] =
        runtimePath;

      // In dev mode, watch the app directory for new/deleted files and
      // regenerate the virtual module
      if (isDev) {
        config.plugins.push({
          name: "fs-router-watcher",
          apply(compiler: any) {
            let prevSource = routesSource;

            compiler.hooks.beforeCompile.tapAsync(
              "fs-router-watcher",
              (_params: any, callback: () => void) => {
                const newSource = generateRoutesModule(appDir, appDirAbs);
                if (newSource !== prevSource) {
                  prevSource = newSource;
                  virtualPlugin.writeModule(
                    virtualModuleName,
                    newSource
                  );
                }
                callback();
              }
            );
          },
        });
      }

      return config;
    });
  },
});
