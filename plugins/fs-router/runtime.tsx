import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  createContext,
  useContext,
  Suspense,
  lazy,
  Component,
  type ComponentType,
  type ReactNode,
  type ErrorInfo,
} from "react";

// Import the auto-generated route manifest from the virtual module
// @ts-ignore — virtual module generated by plugin-fs-router
import {
  pages,
  layouts,
  notFounds,
  loadings,
  errors,
  routePrefix,
} from "virtual-fs-routes";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export type RouteParams = Record<string, string>;

type RouterContextValue = {
  pathname: string;
  params: RouteParams;
  navigate: (to: string) => void;
};

type ModuleLoader<T> = () => Promise<{ default: T }>;

type RouteEntry = {
  pattern: RegExp;
  paramNames: string[];
  page: ModuleLoader<ComponentType<unknown>>;
  layouts: ModuleLoader<ComponentType<{ children: ReactNode }>>[];
  loadings: ModuleLoader<ComponentType>[];
  errors: ModuleLoader<ComponentType<{ error: Error; reset: () => void }>>[];
  notFound: ModuleLoader<ComponentType> | null;
};

// ---------------------------------------------------------------------------
// Base path — reads from Rsbuild's server.base via import.meta.env.BASE_URL
// ---------------------------------------------------------------------------

const BASE = (import.meta.env.BASE_URL ?? "/").replace(/\/+$/, "") || "";

function stripBase(browserPath: string): string {
  if (BASE && browserPath.startsWith(BASE)) {
    const rest = browserPath.slice(BASE.length);
    return rest.startsWith("/") ? rest : "/" + rest;
  }
  return browserPath;
}

function withBase(routePath: string): string {
  if (!BASE) return routePath;
  return BASE + (routePath.startsWith("/") ? routePath : "/" + routePath);
}

// ---------------------------------------------------------------------------
// Context
// ---------------------------------------------------------------------------

const RouterContext = createContext<RouterContextValue>({
  pathname: "/",
  params: {},
  navigate: () => {},
});

export function useRouter() {
  return useContext(RouterContext);
}

export function useParams(): RouteParams {
  return useContext(RouterContext).params;
}

// ---------------------------------------------------------------------------
// Link
// ---------------------------------------------------------------------------

export function Link({
  href,
  children,
  ...props
}: React.AnchorHTMLAttributes<HTMLAnchorElement> & { href: string }) {
  const { navigate } = useRouter();

  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
    if (
      e.button !== 0 ||
      e.metaKey ||
      e.ctrlKey ||
      e.altKey ||
      e.shiftKey ||
      e.defaultPrevented
    )
      return;
    e.preventDefault();
    navigate(href);
  };

  const fullHref = withBase(href);

  return (
    <a href={fullHref} onClick={handleClick} {...props}>
      {children}
    </a>
  );
}

// ---------------------------------------------------------------------------
// Error Boundary
// ---------------------------------------------------------------------------

type ErrorBoundaryProps = {
  fallback: ComponentType<{ error: Error; reset: () => void }>;
  children: ReactNode;
};

type ErrorBoundaryState = {
  error: Error | null;
};

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("[fs-router] Error caught by error boundary:", error, errorInfo);
  }

  reset = () => {
    this.setState({ error: null });
  };

  render() {
    if (this.state.error) {
      const Fallback = this.props.fallback;
      return <Fallback error={this.state.error} reset={this.reset} />;
    }
    return this.props.children;
  }
}

// ---------------------------------------------------------------------------
// Build routes from the virtual manifest
// ---------------------------------------------------------------------------

const pageModules = pages as Record<string, ModuleLoader<ComponentType<unknown>>>;
const layoutModules = layouts as Record<
  string,
  ModuleLoader<ComponentType<{ children: ReactNode }>>
>;
const notFoundModules = notFounds as Record<string, ModuleLoader<ComponentType>>;
const loadingModules = loadings as Record<string, ModuleLoader<ComponentType>>;
const errorModules = errors as Record<
  string,
  ModuleLoader<ComponentType<{ error: Error; reset: () => void }>>
>;

function filePathToSegments(filePath: string): string[] {
  const prefix = new RegExp(`^\\/${routePrefix}\\/`);
  const withoutPrefix = filePath
    .replace(prefix, "")
    .replace(/(^|\/)(?:page|layout|not-found|loading|error)\.tsx$/, "");
  if (!withoutPrefix) return [];
  return withoutPrefix.split("/");
}

function buildRoutePattern(segments: string[]): {
  pattern: RegExp;
  paramNames: string[];
} {
  const paramNames: string[] = [];

  if (segments.length === 0) {
    return { pattern: /^\/$/, paramNames };
  }

  const parts = segments.map((seg) => {
    if (seg.startsWith("[...") && seg.endsWith("]")) {
      const name = seg.slice(4, -1);
      paramNames.push(name);
      return "(.+)";
    }
    if (seg.startsWith("[") && seg.endsWith("]")) {
      const name = seg.slice(1, -1);
      paramNames.push(name);
      return "([^/]+)";
    }
    return seg.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  });

  return {
    pattern: new RegExp(`^/${parts.join("/")}$`),
    paramNames,
  };
}

/**
 * Find special files (layouts, loadings, errors) for a given page's segments.
 * Walks from root to the page's directory, collecting any matching files at each level.
 */
function findSpecialFiles<T>(
  pageSegments: string[],
  modules: Record<string, ModuleLoader<T>>,
  fileName: string
): ModuleLoader<T>[] {
  const result: ModuleLoader<T>[] = [];

  // Root level: /routes/<fileName>.tsx
  const rootKey = `/${routePrefix}/${fileName}.tsx`;
  if (modules[rootKey]) {
    result.push(modules[rootKey]);
  }

  // Nested levels
  let current = `/${routePrefix}`;
  for (const seg of pageSegments) {
    current += `/${seg}`;
    const key = `${current}/${fileName}.tsx`;
    if (modules[key]) {
      result.push(modules[key]);
    }
  }

  return result;
}

/**
 * Find the closest not-found file for a given path.
 * Walks from the deepest segment up to root, returning the first match.
 */
function findClosestNotFound(
  pageSegments: string[]
): ModuleLoader<ComponentType> | null {
  // Build all possible paths from deepest to root
  const paths: string[] = [];
  let current = `/${routePrefix}`;
  const accumulated = [current];
  for (const seg of pageSegments) {
    current += `/${seg}`;
    accumulated.push(current);
  }

  // Check from deepest to root
  for (let i = accumulated.length - 1; i >= 0; i--) {
    const key = `${accumulated[i]}/not-found.tsx`;
    if (notFoundModules[key]) {
      return notFoundModules[key];
    }
  }

  // Check root not-found
  const rootKey = `/${routePrefix}/not-found.tsx`;
  if (notFoundModules[rootKey]) {
    return notFoundModules[rootKey];
  }

  return null;
}

const routes: RouteEntry[] = Object.keys(pageModules)
  .map((filePath) => {
    const segments = filePathToSegments(filePath);
    const { pattern, paramNames } = buildRoutePattern(segments);
    return {
      pattern,
      paramNames,
      page: pageModules[filePath],
      layouts: findSpecialFiles(segments, layoutModules, "layout"),
      loadings: findSpecialFiles(segments, loadingModules, "loading"),
      errors: findSpecialFiles(segments, errorModules, "error"),
      notFound: findClosestNotFound(segments),
    };
  })
  .sort((a, b) => {
    const aHasCatchAll = a.pattern.source.includes("(.+)");
    const bHasCatchAll = b.pattern.source.includes("(.+)");
    if (aHasCatchAll !== bHasCatchAll) return aHasCatchAll ? 1 : -1;
    if (a.paramNames.length !== b.paramNames.length)
      return a.paramNames.length - b.paramNames.length;
    return 0;
  });

// ---------------------------------------------------------------------------
// Match
// ---------------------------------------------------------------------------

function matchRoute(pathname: string): {
  route: RouteEntry;
  params: RouteParams;
} | null {
  for (const route of routes) {
    const match = pathname.match(route.pattern);
    if (match) {
      const params: RouteParams = {};
      route.paramNames.forEach((name, i) => {
        params[name] = match[i + 1];
      });
      return { route, params };
    }
  }
  return null;
}

// ---------------------------------------------------------------------------
// Lazy component cache
// ---------------------------------------------------------------------------

const lazyCache = new Map<
  Function,
  React.LazyExoticComponent<ComponentType<any>>
>();

function getLazy(loader: () => Promise<{ default: ComponentType<any> }>) {
  let cached = lazyCache.get(loader);
  if (!cached) {
    cached = lazy(loader);
    lazyCache.set(loader, cached);
  }
  return cached;
}

// ---------------------------------------------------------------------------
// Default fallbacks
// ---------------------------------------------------------------------------

function DefaultNotFound() {
  return (
    <div style={{ padding: "2rem", textAlign: "center" }}>
      <h1 style={{ fontSize: "2rem", fontWeight: 700 }}>404</h1>
      <p>Page not found</p>
    </div>
  );
}

function DefaultLoading() {
  return null;
}

// ---------------------------------------------------------------------------
// Router component
// ---------------------------------------------------------------------------

export function Router() {
  const [pathname, setPathname] = useState(() =>
    stripBase(window.location.pathname)
  );

  const navigate = useCallback((to: string) => {
    window.history.pushState(null, "", withBase(to));
    setPathname(to.startsWith("/") ? to : "/" + to);
  }, []);

  useEffect(() => {
    const onPop = () => setPathname(stripBase(window.location.pathname));
    window.addEventListener("popstate", onPop);
    return () => window.removeEventListener("popstate", onPop);
  }, []);

  const matched = useMemo(() => matchRoute(pathname), [pathname]);

  const contextValue = useMemo(
    () => ({ pathname, params: matched?.params ?? {}, navigate }),
    [pathname, matched, navigate]
  );

  if (!matched) {
    // No route matched — show the global (root) not-found if it exists
    const rootNotFoundKey = `/${routePrefix}/not-found.tsx`;
    const GlobalNotFound = notFoundModules[rootNotFoundKey]
      ? getLazy(notFoundModules[rootNotFoundKey])
      : null;

    // Wrap in root layout if it exists
    const rootLayoutKey = `/${routePrefix}/layout.tsx`;
    const RootLayout = layoutModules[rootLayoutKey]
      ? getLazy(layoutModules[rootLayoutKey])
      : null;

    let notFoundElement: ReactNode = GlobalNotFound ? (
      <Suspense fallback={<DefaultLoading />}>
        <GlobalNotFound />
      </Suspense>
    ) : (
      <DefaultNotFound />
    );

    if (RootLayout) {
      notFoundElement = (
        <Suspense fallback={<DefaultLoading />}>
          <RootLayout>{notFoundElement}</RootLayout>
        </Suspense>
      );
    }

    return (
      <RouterContext.Provider value={contextValue}>
        {notFoundElement}
      </RouterContext.Provider>
    );
  }

  const { route } = matched;
  const Page = getLazy(route.page);

  // Determine the loading fallback for the page (closest loading.tsx)
  const pageLoadingFallback =
    route.loadings.length > 0
      ? getLazy(route.loadings[route.loadings.length - 1])
      : null;

  // Start with the page wrapped in Suspense
  let element: ReactNode = (
    <Suspense
      fallback={pageLoadingFallback ? <PageLoadingWrapper loader={route.loadings[route.loadings.length - 1]} /> : <DefaultLoading />}
    >
      <Page />
    </Suspense>
  );

  // Wrap in error boundaries (innermost first = closest to page)
  // Error boundaries wrap from inside out, so the closest error.tsx catches first
  for (let i = route.errors.length - 1; i >= 0; i--) {
    const errorLoader = route.errors[i];
    const ErrorFallback = getLazy(errorLoader);
    const inner = element;
    element = <ErrorBoundary fallback={ErrorFallback}>{inner}</ErrorBoundary>;
  }

  // Wrap in layouts (outermost first)
  for (let i = route.layouts.length - 1; i >= 0; i--) {
    const Layout = getLazy(route.layouts[i]);
    const inner = element;

    // Each layout gets its own loading fallback if one exists at that level
    const layoutLoading =
      i < route.loadings.length ? route.loadings[i] : null;

    element = (
      <Suspense
        fallback={layoutLoading ? <PageLoadingWrapper loader={layoutLoading} /> : <DefaultLoading />}
      >
        <Layout>{inner}</Layout>
      </Suspense>
    );
  }

  return (
    <RouterContext.Provider value={contextValue}>
      {element}
    </RouterContext.Provider>
  );
}

/**
 * Helper component that lazily renders a loading component.
 * This is needed because loading.tsx itself is lazy-loaded.
 */
function PageLoadingWrapper({ loader }: { loader: ModuleLoader<ComponentType> }) {
  const Loading = getLazy(loader);
  return (
    <Suspense fallback={<DefaultLoading />}>
      <Loading />
    </Suspense>
  );
}
